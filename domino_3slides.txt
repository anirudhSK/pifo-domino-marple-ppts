Slide 1: The problem
============
--> Given: algorithms that need to run 1B times/sec.
--> Question: what *reusable* primitives do we need for these algorithms?
(The interesting problem isn't a compiler)

Slide 2: A tool to extracts patterns from algorithms.
============
First, pane at the top:
------------------

* The underlying hardware is pipelined.

(speak about how
  this isn't a standard multi-core processor:
  no memory sharing,
  no locks, deterministic, worst-case guarantees.
  very stripped down
)

--> so what part of the algorithm runs in each stage of the pipeline?
--> can we pipeline the algorithm into reusable primitives?

What we built: A tool (could use the term compiler) to pipeline algorithms
1. Input: Algorithms written in a DSL (briefly describe DSL).
(cartoon of scroll with algorithm)

2. Output: Codelets in a maximally pipelined implementation.
(cartoon of sampling's pipeline).

Slide 3: how the tool works?
===========
Strongly connected components.
Bring out the stateless/stateful distinction here.

Slide 4: What we learned
(catalog of instruction set to algorithm mappings)
===========
0. pairwise stateless operations => all stateless operations we saw.
1. Test and set => bloom filter, indicator variables (did I see a SYN?)
2. Counter => Heavy hitters, other count-based algorithms.
3. 2-way predicated increments => RCP, flowlet switching, sampling.
4. Paired-wise updates => CONGA (a load-balancing algorithm)
5. Maybe? (lookup table) for CoDel's square root?

Even if you built a circuit that incorporated all of these elements,
it's less than a few percent in area.

Future work: Do these instructions generalize? Can we formulate this as a ML
problem? We only picked ten algorithms here.

Potential questions:
------
Q1. Why use a compiler?
Ans: Beyond a few lines, I can't reason manually. It's always good to have
someone check your work. It takes much longer and much more ingenuity to do it
manually (Steve Licking).

Q2. Other parts of the compiler 

SKETCH is no longer important when the compiler is used as a tool.
Maybe don't even need critical path scheduling.
Because we are identifying patterns here, not deciding how many of each we
need.
