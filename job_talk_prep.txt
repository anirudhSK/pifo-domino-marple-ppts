Domino in three slides:

Slide 1: The problem
============
--> So we have these pieces of code (scheduling, queue management, cong ctrl)
we want to run at high speed (1 billion times a second).

--> Question: what instructions/primitives do we need for high-speed execution?
--> Question: how do we bridge the gap from code to instructions?
--> Answer: A compiler.
Show:
Block diag of compiler: (my flashing animation)
Input: Description of router pipeline and code
Output: Does it map? What's the mapping?
Iterative procedure, much like the early days of RISC.
Allows us to explore different instruction sets and see what works best.

Why do we need our own new compiler?
Answer: This isn't like a standard multi-core processor: no memory sharing,
no locks, deterministic, worst-case guarantees.

Slide 2: What we built (animate on the block diagram from previous page)
============
1. A language for writing the algorithms.
2. A model for the target architecture.
3. A compiler to go between them.

Next few slides: Describe each of 1--3 in as much detail as you want.

Slide 4: What we learned (catalog of instruction set to algorithm mappings)
===========
1. Test and set => bloom filter.
2. Counter => Heavy hitters
A few more.
Say all instrs are feasible today.
